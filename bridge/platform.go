package bridge

import (
	"encoding/json"

	"github.com/google/uuid"
	"github.com/pkg/errors"
)

// PlatformBridge is the interface that describes a bridge to communicate from
// Go to a platform.
type PlatformBridge interface {
	// Request issues a request to the specified URL with the payload.
	Request(url string, payload interface{}) (response Payload, err error)

	// RequestWithAsyncResponse issues a request to the specified URL with the
	// payload.
	// It should be used when the response require to wait platform asynchronous
	// operations.
	RequestWithAsyncResponse(url string, payload interface{}) (response Payload, err error)

	// Return returns the response with the identifier generated by a call to
	// RequestWithAsyncResponse.
	// It should be called just after a Go function call from platform.
	Return(returnID string, response []byte, err error)
}

// PlatformHandler describes the func that will handle platform requests.
type PlatformHandler func(url string, payload []byte, returnID string) (response []byte, err error)

// NewPlatformBridge creates a platform bridge.
func NewPlatformBridge(h PlatformHandler) PlatformBridge {
	return newPlatformBridge(h)
}

type platformBridge struct {
	handler PlatformHandler
	returns *returnRegistry
}

func newPlatformBridge(h PlatformHandler) *platformBridge {
	return &platformBridge{
		handler: h,
		returns: newReturnRegistry(),
	}
}

func (b *platformBridge) Request(rawurl string, payload interface{}) (response Payload, err error) {
	var data []byte
	if data, err = json.Marshal(payload); err != nil {
		err = errors.Wrap(err, "invalid payload")
		return
	}

	var resdata []byte
	if resdata, err = b.handler(rawurl, data, ""); err != nil {
		return
	}
	response = jsonPayload(resdata)
	return
}

func (b *platformBridge) RequestWithAsyncResponse(rawurl string, payload interface{}) (response Payload, err error) {
	var data []byte
	if data, err = json.Marshal(payload); err != nil {
		err = errors.Wrap(err, "invalid payload")
		return
	}

	returnID := uuid.New()

	retchan := make(chan returnPayload, 1)
	defer close(retchan)

	b.returns.Set(returnID, retchan)
	defer b.returns.Delete(returnID)

	if _, err = b.handler(rawurl, data, returnID.String()); err != nil {
		return
	}

	ret := <-retchan
	response = ret.response
	err = ret.err
	return
}

func (b *platformBridge) Return(returnID string, response []byte, err error) {
	retID, err := uuid.Parse(returnID)
	if err != nil {
		panic(err)
	}

	retchan, ok := b.returns.Get(retID)
	if !ok {
		panic(errors.Errorf("no return set for %v", retID))
	}
	retchan <- returnPayload{
		response: jsonPayload(response),
		err:      err,
	}
}
