package bridge

import (
	"encoding/json"
	"sync"

	"github.com/google/uuid"
	"github.com/pkg/errors"
)

// PlatformBridge is the interface that describes a bridge to communicate from
// Go to a platform.
type PlatformBridge interface {
	// Request issues a request to the specified URL with the payload.
	Request(url string, payload interface{}) (res PlatformResponse, err error)

	// RequestWithAsyncResponse issues a request to the specified URL with the
	// payload.
	// It should be used when the response require to wait platform asynchronous
	// operations.
	RequestWithAsyncResponse(url string, payload interface{}) (res PlatformResponse, err error)

	// Return returns the response with the identifier generated by a call to
	// RequestWithAsyncResponse.
	// It should be called just after a Go function call from platform.
	Return(returnID uuid.UUID, response []byte, err error)
}

// PlatformResponse is the interface that describes a platform response.
type PlatformResponse interface {
	// Unmarshal parses the encoded response and stores the result in the value
	// pointed to by v.
	// If v is nil or not a pointer, Unmarshal returns an error.
	Unmarshal(v interface{}) error
}

type PlatformRequestAdapter func(url string, payload []byte, returnID string) (response []byte, err error)

// NewPlatformBridge creates a platform bridge.
func NewPlatformBridge(adpater PlatformRequestAdapter) PlatformBridge {
	return newPlatformBridge(adpater)
}

type platformBridge struct {
	adapter PlatformRequestAdapter
	returns *returnRegistry
}

func newPlatformBridge(adapter PlatformRequestAdapter) *platformBridge {
	return &platformBridge{
		adapter: adapter,
		returns: newReturnRegistry(),
	}
}

func (b *platformBridge) Request(rawurl string, payload interface{}) (res PlatformResponse, err error) {
	var data []byte
	if data, err = json.Marshal(payload); err != nil {
		err = errors.Wrap(err, "invalid payload")
		return
	}

	var resdata []byte
	if resdata, err = b.adapter(rawurl, data, ""); err != nil {
		return
	}
	res = jsonResponse(resdata)
	return
}

func (b *platformBridge) RequestWithAsyncResponse(rawurl string, payload interface{}) (res PlatformResponse, err error) {
	var data []byte
	if data, err = json.Marshal(payload); err != nil {
		err = errors.Wrap(err, "invalid payload")
		return
	}

	returnID := uuid.New()

	retchan := make(chan returnPayload, 1)
	defer close(retchan)

	b.returns.Set(returnID, retchan)
	defer b.returns.Delete(returnID)

	if _, err = b.adapter(rawurl, data, returnID.String()); err != nil {
		return
	}

	ret := <-retchan
	res = ret.response
	err = ret.err
	return
}

func (b *platformBridge) Return(returnID uuid.UUID, response []byte, err error) {
	retchan, ok := b.returns.Get(returnID)
	if !ok {
		panic(errors.Errorf("no return set for %v", returnID))
	}
	retchan <- returnPayload{
		response: jsonResponse(response),
		err:      err,
	}
}

type jsonResponse []byte

func (r jsonResponse) Unmarshal(v interface{}) error {
	return json.Unmarshal(r, v)
}

type returnPayload struct {
	response PlatformResponse
	err      error
}

type returnRegistry struct {
	mutex   sync.Mutex
	returns map[uuid.UUID]chan returnPayload
}

func newReturnRegistry() *returnRegistry {
	return &returnRegistry{
		returns: make(map[uuid.UUID]chan returnPayload),
	}
}

func (r *returnRegistry) Set(id uuid.UUID, retchan chan returnPayload) {
	r.mutex.Lock()
	r.returns[id] = retchan
	r.mutex.Unlock()
}

func (r *returnRegistry) Get(id uuid.UUID) (retchan chan returnPayload, ok bool) {
	r.mutex.Lock()
	retchan, ok = r.returns[id]
	r.mutex.Unlock()
	return
}

func (r *returnRegistry) Delete(id uuid.UUID) {
	r.mutex.Lock()
	delete(r.returns, id)
	r.mutex.Unlock()
}
